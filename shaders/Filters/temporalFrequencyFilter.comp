#version 450
#extension GL_GOOGLE_include_directive : enable
#include "../common.h"

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba32f) uniform readonly image2D inNoisyImage;
layout (binding = 1, rgba32f) uniform image2DArray accumImage;
layout (binding = 2, rg32f) uniform image2DArray dftImage;
layout (binding = 3, rgba32f) uniform image2D outDenoisedImage;

layout (push_constant) uniform pcBlock {
	uint frameIndex;
	uint temporalSamples;
	uint dftComponent;
} pcb;

vec2 complexExp(in float x)
{
	float arg = 2 * PI * x;

	return vec2(cos(arg), sin(arg));
}

vec2 complexMul(in vec2 x, in vec2 y)
{
	return vec2(x.r * y.r - x.g * y.g, x.r * y.g + x.g * y.r);
}

float complexAbs(in vec2 x)
{
	return sqrt(x.r * x.r + x.g * x.g);
}

float updateDFT(in vec4 new, in vec4 old, in ivec2 pixel)
{
	uint nDftElements = (pcb.temporalSamples >> 1) + 1;
	vec2 update = vec2((new.r + new.g + new.b - old.r - old.g - old.b) / 3.0, 0);
	
	float dftFrequencyRepr = 0;
	float normalization = 0;
	for (uint i = 0; i < nDftElements; i++) {
		vec2 cExp = complexExp(float(i) / pcb.temporalSamples);
		vec2 dftElement = imageLoad(dftImage, ivec3(pixel, i)).rg + update;
		vec2 newDftElement = complexMul(dftElement, cExp);
		imageStore(dftImage, ivec3(pixel, i), vec4(newDftElement, 0, 0));

		if (i == pcb.dftComponent) {
			dftFrequencyRepr = sqrt(newDftElement.r * newDftElement.r + newDftElement.g * newDftElement.g);
			normalization = 1;
		}
	}

	return dftFrequencyRepr / normalization;
}

float bruteForceDftCompare(in uint startIdx, in ivec2 pixel)
{	
	uint nDftElements = (pcb.temporalSamples >> 1) + 1;

	float error = 0;
	for (uint i = 0; i < nDftElements; i++) {
		vec2 dftElement = vec2(0);
		for (uint j = 0; j < pcb.temporalSamples; j++) {
			float arg = -1.0 * (int(j) - int(startIdx)) * float(i) / pcb.temporalSamples;
			vec2 cExp = complexExp(arg);

			vec4 element = imageLoad(accumImage, ivec3(pixel, j)).rgba;

			dftElement += complexMul(cExp, vec2((element.r + element.g + element.b)/3.0, 0));
		}

		vec2 dftElementRef = imageLoad(dftImage, ivec3(pixel, i)).rg;
		vec2 delta = dftElementRef - dftElement;
		error += sqrt(delta.r * delta.r + delta.g * delta.g);

		//error += abs(complexAbs(dftElementRef) - complexAbs(dftElement));
	}

	return error;
}

void main()
{	
	ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	vec4 newElement = imageLoad(inNoisyImage, pixel).rgba;
	uint startIndex = pcb.frameIndex %  pcb.temporalSamples;
	vec4 oldElement = imageLoad(accumImage, ivec3(pixel, startIndex)).rgba;
	imageStore(accumImage, ivec3(pixel, startIndex), newElement);

	float dftSummary = updateDFT(newElement, oldElement, pixel);

	//float error = bruteForceDftCompare((startIndex + 1) % pcb.temporalSamples, pixel);

	vec4 filteredPix = vec4(0);
	for (uint i = 0; i < pcb.temporalSamples; i++) {
		filteredPix += imageLoad(accumImage, ivec3(pixel, i)).rgba;
	}

	//imageStore(outDenoisedImage, pixel, filteredPix / pcb.temporalSamples);
	imageStore(outDenoisedImage, pixel, vec4(vec3(dftSummary), 0));
}