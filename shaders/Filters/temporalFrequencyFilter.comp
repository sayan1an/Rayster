#version 450
#extension GL_GOOGLE_include_directive : enable
#include "filterParams.h"
#include "../commonMath.h"

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, set = 0, rgba32f) uniform readonly image2D inNoisyImage;
layout (binding = 1, set = 0, rgba32f) uniform image2DArray accumImage;
layout (binding = 2, set = 0) buffer DftBuffer { mat3x2 data[]; } dftBuffer;
layout (binding = 3, set = 0, rgba32f) uniform image2D outDenoisedImage;

layout (push_constant) uniform pcBlock {
	uint frameIndex;
	uint dftInfo; // Starting LSB  8 bit - number of samples, 8 bit - dftComponent to display, 8 bit - index of sample to recover after filtering (0 is oldest while max is latest), 8 bit mode 
	uint imageInfo; // Staring LSB 16 bit - image width, 16 bit -image height
} pcb;

mat3x2 loadDftBuffer(in ivec2 imageExtent, in ivec2 pixel, in uint dftComponent)
{	
	uint index = dftComponent * imageExtent.x * imageExtent.y + pixel.y * imageExtent.x + pixel.x;

	return dftBuffer.data[index];
}

void storeDftBuffer(in ivec2 imageExtent, in ivec2 pixel, in uint dftComponent, in mat3x2 data)
{
	uint index = dftComponent * imageExtent.x * imageExtent.y + pixel.y * imageExtent.x + pixel.x;

	dftBuffer.data[index] = data;
}

vec3 updateDFT(in vec3 difference, in ivec2 imageExtent, in ivec2 pixel, in uvec4 dftInfo)
{
	uint nDftElements = (dftInfo.x >> 1) + 1;
	mat3x2 update = mat3x2(difference.r, 0, difference.g, 0,  difference.b, 0);

	vec3 dftFrequencyRepr = vec3(0);
	for (uint i = 0; i < nDftElements; i++) {
		vec2 cExp = complexExp(float(i) / dftInfo.x);
		mat3x2 newDftElement = complexMul(loadDftBuffer(imageExtent, pixel, i) + update, cExp);
		
		float multiplier = (i == 0  || (i == nDftElements - 1 && (dftInfo.x & 1) == 0)) ? 1.0 : 2.0;

		dftFrequencyRepr += complexMulReal(newDftElement, complexExp(float(i * dftInfo.z) / dftInfo.x)) * multiplier / dftInfo.x;
		
		storeDftBuffer(imageExtent, pixel, i, newDftElement);
	}

	return dftFrequencyRepr;
}

vec3 bruteForceDftCompare(in uint startIdx, in ivec2 imageExtent, in ivec2 pixel, in uint temporalSamples)
{	
	uint nDftElements = (temporalSamples >> 1) + 1;

	vec3 error = vec3(0);
	for (uint i = 0; i < nDftElements; i++) {
		mat3x2 dftElement = mat3x2(0);
		for (uint j = 0; j < temporalSamples; j++) {
			float arg = -1.0 * (int(j) - int(startIdx)) * float(i) / temporalSamples;
			vec2 cExp = complexExp(arg);
			vec4 element = imageLoad(accumImage, ivec3(pixel, j)).rgba;
			dftElement += complexMul(mat3x2(element.r, 0, element.g, 0, element.b, 0), cExp);
		}

		mat3x2 dftElementRef = loadDftBuffer(imageExtent, pixel, i);
		mat3x2 delta = dftElementRef - dftElement;
		error += vec3(length(delta[0]), length(delta[1]), length(delta[2]));
	}

	return error;
}

void main()
{	
	ivec2 imageExtent = ivec2(pcb.imageInfo & 0xffff, pcb.imageInfo >> 16); 
	ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	
	if (pixel.x < imageExtent.x && pixel.y < imageExtent.y) {
		vec4 newElement = imageLoad(inNoisyImage, pixel).rgba;
		uvec4  dftInfo = uvec4(pcb.dftInfo & 0xff, (pcb.dftInfo >> 8) & 0xff, (pcb.dftInfo >> 16) & 0xff, pcb.dftInfo >> 24);
		
		if (dftInfo.w == TEMPORAL_FREQ_FILT_MODE_4) {
			mat3x2 data = mat3x2(0);
			
			for (uint i = 0; i < ((MAX_TEMPORAL_FREQ_FILT_SAMPLES >> 1) + 1); i++) 
				storeDftBuffer(imageExtent, pixel, i, mat3x2(0));

			for (uint i = 0; i < MAX_TEMPORAL_FREQ_FILT_SAMPLES; i++)
				 imageStore(accumImage, ivec3(pixel, i), vec4(0));
		}
	
		uint startIndex = pcb.frameIndex %  dftInfo.x;
		vec4 oldElement = imageLoad(accumImage, ivec3(pixel, startIndex)).rgba;
		imageStore(accumImage, ivec3(pixel, startIndex), newElement);
		
		vec3 displayOut = updateDFT((newElement - oldElement).rgb, imageExtent, pixel, dftInfo);

		if (dftInfo.w == TEMPORAL_FREQ_FILT_MODE_1)
			displayOut -= imageLoad(accumImage, ivec3(pixel, (startIndex + 1 + dftInfo.z) % dftInfo.x)).rgb;
		else if (dftInfo.w == TEMPORAL_FREQ_FILT_MODE_2) {
			mat3x2 dftComponent = loadDftBuffer(imageExtent, pixel, dftInfo.y);
			displayOut = vec3(length(dftComponent[0]), length(dftComponent[1]), length(dftComponent[2]));
		}
		else if (dftInfo.w == TEMPORAL_FREQ_FILT_MODE_3)
			displayOut = bruteForceDftCompare((startIndex + 1) % dftInfo.x, imageExtent, pixel, dftInfo.x);
		

		imageStore(outDenoisedImage, pixel, vec4(displayOut, 0));
	}
}