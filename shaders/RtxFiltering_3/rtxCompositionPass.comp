#version 450
#extension GL_GOOGLE_include_directive : enable

#include "hostDeviceShared.h"
layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba8) uniform image2D diffuseTex;
layout (binding = 1, rgba8) uniform image2D specularTex;
layout (binding = 2, rg16f) uniform image2D motionVectorImg;
layout (binding = 3, rgba32f) uniform image2DArray rtxInOut;
layout (binding = 4) uniform sampler2DArray rtxIn2;
layout (binding = 5) uniform sampler2DArray rtxIn3;
layout (binding = 6, rg16f) uniform image2D blendeWeight;
layout (binding = 7, rg32f) uniform image2DArray inMcState; // layer 0 contains state, layer 1 contains mcmc value and moving weight
layout (binding = 8, rgba32f) uniform image2DArray accumBuffer;

layout (push_constant) uniform pcBlock {
	uint choice;
	uint motionVector;
	float brightness;
} pcb;

void main()
{	
	ivec2 viewportSize = imageSize(diffuseTex);
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	vec4 outCol = vec4(0);
	vec4 outColNoTex = vec4(0);

	if (pcb.choice == 0) {
		vec2 texCoord = (vec2(pixel) + vec2(0.5)) / viewportSize;
		vec4 diffTex = imageLoad(diffuseTex, pixel);
		vec4 specTex = imageLoad(specularTex, pixel);
		
		uint isValid = length(diffTex.xyz) + length(specTex.xyz) > 0 ? 1 : 0;
		vec2 motionVector = pcb.motionVector > 0 ? imageLoad(motionVectorImg, pixel).rg : vec2(0);

		vec2 pixelMotion = clamp(pixel + vec2(0.5) + motionVector, vec2(0), viewportSize);
		vec3 diffCompOld = imageLoad(accumBuffer, ivec3(pixelMotion, 0)).rgb * isValid;
		vec3 specCompOld = imageLoad(accumBuffer, ivec3(pixelMotion, 1)).rgb * isValid;

		vec4 diffComp1 = imageLoad(rtxInOut, ivec3(pixel, 0));
		vec4 specComp1 = imageLoad(rtxInOut, ivec3(pixel, 1));

		vec4 diffComp2 = texture(rtxIn2, vec3(texCoord, 0));
		vec4 specComp2 = texture(rtxIn2, vec3(texCoord, 1));

		vec4 diffComp3 = texture(rtxIn3, vec3(texCoord, 0));
		vec4 specComp3 = texture(rtxIn3, vec3(texCoord, 1));
		
		vec4 diffComp = diffComp1 + diffComp2 + diffComp3;
		vec4 specComp = specComp1 + specComp2 + specComp3;

		diffComp.xyz /= diffComp.w;
		specComp.xyz /= diffComp.w;

		diffComp.w = 1;
		specComp.w = 1;

		float oWeight = imageLoad(blendeWeight, pixel).r;
		diffComp.xyz = oWeight * diffCompOld + (1 - oWeight) * diffComp.xyz;
		specComp.xyz = oWeight * specCompOld + (1 - oWeight) * specComp.xyz;

		outCol = diffTex * diffComp + specTex * specComp;
		// captures the power of texture, not the details
		outColNoTex = length(diffTex.xyz) * diffComp + length(specTex.xyz) * specComp;
		outColNoTex.w = 1;
		outCol.w = 1;

		outCol = (diffComp.x + diffComp.y + diffComp.z) < -1 ? vec4(0,1,0,1) : outCol;
		//outCol.xy = abs(motionVector);
		//outCol.z = 0;
		imageStore(accumBuffer, ivec3(pixel, 0), diffComp);
		imageStore(accumBuffer, ivec3(pixel, 1), specComp);
	}
	else if (pcb.choice == 1) {
		float mcmcVal = imageLoad(inMcState, ivec3(pixel, 1)).r;	
		outColNoTex = vec4(vec3(mcmcVal), 1);
		outCol = mcmcVal < -0.5 ? vec4(0,1,0,1) : outColNoTex;
	}

	imageStore(rtxInOut, ivec3(pixel, 0), pcb.brightness * outCol);
	imageStore(rtxInOut, ivec3(pixel, 1), outColNoTex);
}