#version 450
#extension GL_GOOGLE_include_directive : enable

#include "../commonMath.h"
#include "../hostDeviceShared.h"
#include "hostDeviceShared.h"

layout (local_size_x = 2, local_size_y = 2) in;

layout(binding = 0, rgba32f) uniform readonly image2D normalImage;
layout(binding = 1, rgba16f) uniform readonly image2D otherImage;
layout(binding = 2, rg16f) uniform readonly image2D motionVectorImage;
layout(binding = 3, rg16f) uniform readonly image2D blendeWeightImage;
layout(binding = 4) uniform CameraProperties 
{
	VIEWPROJ_BLOCK
} cam;

layout(binding = 5) buffer RandomGeneratorState { uint state[]; } randGenState;
layout(binding = 6) readonly buffer LightVertices { vec4 v[]; } lightVertices;
layout(binding = 7) readonly buffer DiscreteCdf { float bins[]; } discreteCdf;
layout(binding = 8) readonly buffer NormDiscreteCdf { float bins[]; } normDiscreteCdf;
layout(binding = 9) readonly buffer UniformToEmitterIdx { uint bins[]; } uniformToEmitterIdx;
layout(binding = 10, rg32f) uniform image2DArray outMcState; // layer 0 contains state, layer 1 contains mcmc value and moving weight
layout(binding = 11, rgba16f) uniform image2DArray outSampleStat;

#if COLLECT_MARKOV_CHAIN_SAMPLES
layout(binding = 12) buffer CollectMCSample { vec4 state[]; } collectMCSample;
#endif

layout (push_constant) uniform pcBlock {
    uint motionVector;
    float cumulativeSum;
	uint uniformToEmitterIndexMapSize;
    float sigma;
    float gamma;
#if COLLECT_MARKOV_CHAIN_SAMPLES
    uint pixelQueryX;
    uint pixelQueryY;
    int resetWeight;
#endif
} pcb;

#define MAX_NEW_SAMPLES_PER_FRAME 8
#define DECAY_RATE 0.95
#define SUBSAMPLE_RATE 2
#define SORTING_ITER 1
#define X_DELTA  (0.001)
#define Y_DELTA  (0.005)

shared vec2 s_mcState[4];
shared vec4 s_samples_1[4][MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME];
shared vec4 s_samples_2[4][MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME];
shared bool s_flag[4][MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME];

void loadSamplesToSharedMem(in ivec2 gid, in uint tid)
{
    for (uint i = 0; i < MAX_SPP; i++) {
        vec4 _sample = imageLoad(outSampleStat, ivec3(gid, i));
        _sample.zw *= DECAY_RATE;
        s_samples_2[tid][i] = _sample;
    }
}

void storeSamplesToSharedMem(in ivec2 gid, in uint tid)
{   
    for (uint i = 0; i < MAX_SPP; i++) {
        //s_samples_1[tid][i].w = 1;
        imageStore(outSampleStat, ivec3(gid, i), s_samples_1[tid][i]);
    }
}

void processSamples(in uint tid, in uint nNewSamples, in float blendeWeight)
{   
    // clear out unused part of buffer
    for (uint i = 0; i < MAX_NEW_SAMPLES_PER_FRAME; i++)
        s_samples_2[tid][MAX_SPP + i] = vec4(0);


    for (uint i = 0; i < MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME; i++)
        s_flag[tid][i] = false;
    
    float blendWeightScale = CLIP(1 - (blendeWeight + 0.03), 0, 1);
    for (uint i = 0; i < nNewSamples; i++) {
        vec3 querySample = s_samples_1[tid][i].xyz;
        s_samples_1[tid][i] = vec4(0);
        float clippedVal = CLIP(querySample.z, 0, 1);
        float scale = (1 + (1 - clippedVal) * 10) * blendWeightScale;

        // insert / update the new samples after the old samples
        for (uint j = 0; j < MAX_SPP + i + 1; j++) {
            vec4 element = s_samples_2[tid][j];
            bool updatePosition = abs(element.w) < 0.001; // Update position if the position is uninitialized
            bool update = updatePosition || ((abs(element.x - querySample.x) < X_DELTA * scale) && (abs(element.y - querySample.y) < Y_DELTA * scale));
            
            element.xy = updatePosition ? querySample.xy : element.xy;
            element.zw = update ? vec2(querySample.z, element.w + 1) : element.zw;
            s_flag[tid][j] = update ? true : s_flag[tid][j];
            s_samples_2[tid][j] = element;

            if (update)
                break; 
        }
     }

    nNewSamples = 0;
    uint nOldSamples = 0;
    for (uint i = 0; i < (MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME); i++) {
        bool update = s_flag[tid][i];
        vec4 element = s_samples_2[tid][i];
        s_samples_1[tid][(MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME) - nNewSamples - 1] = update ? element : vec4(0); // insert new samples at the end
        nNewSamples += (update ? 1 : 0);

        update = (!update) && (element.w > CUTOFF_WEIGHT);        
        s_samples_1[tid][nOldSamples] = update ? element : vec4(0); // insert old samples at the beginning
        nOldSamples += (update ? 1 : 0);
    }

    //semi-importance sample
    //Just do a few pass of bubble sort
    for (uint j = 0; j < SORTING_ITER; j++) {
        for (uint i = j; i + 1 < nOldSamples; i++) {
            vec4 first = s_samples_1[tid][nOldSamples - i - 1];
            vec4 second = s_samples_1[tid][nOldSamples - i - 2];

            bool swap = first.w > second.w;

            s_samples_1[tid][nOldSamples - i - 1] = swap ? second : first;
            s_samples_1[tid][nOldSamples - i - 2] = swap ? first : second;
        }
    }

    uint offset = min(MAX_SPP - nNewSamples, nOldSamples);
    for(uint i = 0; i < nNewSamples; i++)
        s_samples_1[tid][offset + i] = s_samples_1[tid][MAX_SPP + MAX_NEW_SAMPLES_PER_FRAME - i - 1];
}

float proposalDist(in vec2 uv, in vec3 origin, out vec3 lightDirection, out float radiance)
{
    uint index = uniformToEmitterIdx.bins[uint(uv.x * pcb.uniformToEmitterIndexMapSize)];
    float b = discreteCdf.bins[index];
    float a = discreteCdf.bins[index + 1];

    radiance = a - b;    
    
    a /= pcb.cumulativeSum;
    b /= pcb.cumulativeSum;

    vec4 vA = lightVertices.v[3*index];
    vec4 vB = lightVertices.v[3*index + 1];
    vec4 vC = lightVertices.v[3*index + 2];

    float pdf = a - b; 
    // rescale
    uv.x = (uv.x - b) / pdf;

    // convert to bary
    uv.x = 1.0 - sqrt(uv.x);
	uv.y = (1.0 - uv.x) * (1.0 - uv.y);

    lightDirection = vA.xyz * uv.x + vB.xyz * uv.y + vC.xyz * (1.0f - uv.x - uv.y) - origin;
    float distance = length(lightDirection);
    lightDirection /= distance;

    vec3 lightNormal = vec3(vA.w, vB.w, vC.w);
    float lightArea = length(lightNormal);
    lightNormal /= lightArea;

    /*
    lightArea *= 0.5f;
    pdf *= (distance * distance) / (abs(dot(lightDirection, lightNormal)) * lightArea);
    radiance = radianceArea / lightArea;
    */

    // optimized, lightArea cancels out in pdf and radiance terms. 
    pdf *= (distance * distance) / (abs(dot(lightDirection, lightNormal)));

    return pdf;
}

float targetDist(in vec3 surfaceNormal, in vec3 viewDir, in vec3 lightDir, in float radiance, in float bsdfType, in float specularAlpha, in float diffuseProb)
{
    float cos = dot(lightDir, surfaceNormal);
	return cos >= 0 ? radiance * (diffuseProb * (cos / PI) + (1.0f - diffuseProb) * (bsdfType > 0.5f ? ggxBrdf(viewDir, lightDir, surfaceNormal, specularAlpha) : 0)): 0;
}

void main()
{   
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lid = ivec2(gl_LocalInvocationID.xy);
    uint tid = 2*lid.y + lid.x;
    s_mcState[tid] = vec2(-1);

#if COLLECT_MARKOV_CHAIN_SAMPLES
        if (pcb.pixelQueryX == gid.x && pcb.pixelQueryY == gid.y) {
            collectMCSample.state[0].x = MC_SAMPLE_HEADER_SIZE + 0.01f;
            collectMCSample.state[0].y = 0;
        }
#endif
    uint xorshiftState = randGenState.state[gid.y * gl_NumWorkGroups.x * 2 + gid.x];

    vec2 pixelMotion = pcb.motionVector > 0 ? imageLoad(motionVectorImage, gid).rg : vec2(0);// + add offset due to motion vector
    pixelMotion = clamp(gid + vec2(0.5) + pixelMotion, vec2(0), imageSize(outMcState).rg);
    vec2 mcState = imageLoad(outMcState, ivec3(pixelMotion, 0)).rg;
    // optional
    vec2 mcmcVal = pcb.resetWeight > 0 ? vec2(0) : imageLoad(outMcState, ivec3(pixelMotion, 1)).rg; 
    
    const vec4 other = imageLoad(otherImage, gid).rgba;
    const vec4 normalDepth = imageLoad(normalImage, gid).rgba;
    const float blendeWeight = imageLoad(blendeWeightImage, gid).r;
    loadSamplesToSharedMem(ivec2(pixelMotion), tid);

    // assign mcState undefined if primary ray hitting a light source or escaping the scene
    if (other.w < -0.5f || (other.w > 3.5 && other.w < 4.5)) {
        mcState = vec2(0);
        mcmcVal = vec2(0);
    }
    
    // read mcState and use as initial value for the Markov Chain
    // if initial state is undefined, initialize with random value and run the chain longer if necessary 
    else {
        const vec2 pixelCenter = vec2(gid.xy) + vec2(0.5f);
        const vec2 inUV = pixelCenter/vec2(gl_NumWorkGroups.xy * 2);
        vec2 d = inUV * 2.0 - 1.0;

        vec4 origin = cam.viewInv * vec4(0,0,0,1);
        vec4 target = cam.projInv * vec4(d.x, d.y, 1, 1) ;
        vec4 viewDir = cam.viewInv * vec4(normalize(target.xyz), 0) ;
    
        // for shadow rays
        origin = origin + (normalDepth.w - 0.000f) * viewDir;

        bool initialUndefined = (mcState.x == 0);
        vec2 proposedState = initialUndefined ? vec2(xorshift(xorshiftState) / 4294967296.0, xorshift(xorshiftState) / 4294967296.0) : mcState;

        uint mcIterations = 8 + (initialUndefined ? 16 : 0);

        vec3 lightDirection;
        float radiance;

        float prob = proposalDist(proposedState, origin.xyz, lightDirection, radiance);
        float prevProposal = CLIP((targetDist(normalDepth.xyz, -viewDir.xyz, lightDirection, radiance, other.w, other.x, other.z) / prob), 0, MAX_SAMPLE_CLIP_VALUE / 10);

#if COLLECT_MARKOV_CHAIN_SAMPLES
        if (pcb.pixelQueryX == gid.x && pcb.pixelQueryY == gid.y) {
            collectMCSample.state[0].x = MC_SAMPLE_HEADER_SIZE + 0.01f;
            collectMCSample.state[0].y = mcIterations + 0.01f;
        }
#endif
        mcState = proposedState;
        s_mcState[tid] = mcState;

        float currentMcmcVal = 0;
        uint nNewSamples = 0;
        for (uint i = 0; i < mcIterations; i++) {
            // choose two random number in {0, 1, 2}
            uint r1 = xorshift(xorshiftState) % 3; // chose first number in {0,1,2}
            uint r2 = (r1 + 1 + (xorshift(xorshiftState) & 1)) % 3; // choose second, add either 1 or 2 to r1
                    
            uvec2 r = uvec2(r1, r2) + uvec2(tid + 1);
                            
            // propose a value for next iteration
            proposedState = mcState + pcb.gamma * (s_mcState[r.x & 3] - s_mcState[r.y & 3]) + pcb.sigma * uniformToGaussian(vec2(xorshift(xorshiftState) / 4294967296.0, xorshift(xorshiftState) / 4294967296.0));
            proposedState.x = proposedState.x < 0 ? -proposedState.x : (proposedState.x > 1 ? 2 - proposedState.x : proposedState.x);
            proposedState.y = proposedState.y < 0 ? -proposedState.y : (proposedState.y > 1 ? 2 - proposedState.y : proposedState.y);
            
            //proposedState = vec2(xorshift(xorshiftState) / 4294967296.0, xorshift(xorshiftState) / 4294967296.0);

            prob = proposalDist(proposedState, origin.xyz, lightDirection, radiance);
            float currentProposal = CLIP((targetDist(normalDepth.xyz, -viewDir.xyz, lightDirection, radiance, other.w, other.x, other.z) / prob), 0, MAX_SAMPLE_CLIP_VALUE / 10);
            
            bool accepted = ((xorshift(xorshiftState) / 4294967296.0) < min(1.0f, currentProposal / prevProposal));
            
            prevProposal = accepted ? currentProposal : prevProposal;
            mcState = accepted ? proposedState : mcState;

            currentMcmcVal += prevProposal;
#if COLLECT_MARKOV_CHAIN_SAMPLES
            if (pcb.pixelQueryX == gid.x && pcb.pixelQueryY == gid.y)
                collectMCSample.state[i + MC_SAMPLE_HEADER_SIZE] = vec4(mcState.x, mcState.y, prevProposal, 0);
#endif      
            accepted = (nNewSamples < MAX_NEW_SAMPLES_PER_FRAME) && ((xorshift(xorshiftState) & (SUBSAMPLE_RATE - 1)) == 0);
            s_samples_1[tid][nNewSamples & (MAX_SPP - 1)].xyz = accepted ? vec3(mcState.x, mcState.y, prevProposal) : vec3(0);
            nNewSamples += accepted ? 1 : 0;
           
            s_mcState[tid] = mcState;
        }

        mcmcVal.y += currentMcmcVal; // running weight
        mcmcVal.y = CLIP(mcmcVal.y, 0, 1e25);
        float cWeight = currentMcmcVal / mcmcVal.y;
        cWeight = cWeight > 1 ? 1 : (cWeight < 0 ? 0 : cWeight);
        float oWeight = 1 - cWeight;

        currentMcmcVal /= mcIterations;
        mcmcVal.x = cWeight * currentMcmcVal + oWeight * mcmcVal.x;

        processSamples(tid, nNewSamples, blendeWeight);
        storeSamplesToSharedMem(ivec2(gid), tid);
    }

#if COLLECT_MARKOV_CHAIN_SAMPLES
    if (pcb.pixelQueryX == gid.x && pcb.pixelQueryY == gid.y) {
        mcmcVal.x = -1;
    }
#endif        
   
    imageStore(outMcState, ivec3(gid, 0), vec4(mcState.x, mcState.y, 0, 0));
    imageStore(outMcState, ivec3(gid, 1), vec4(mcmcVal.x, mcmcVal.y, 0, 0));
    randGenState.state[gid.y * gl_NumWorkGroups.x * 2 + gid.x] = xorshiftState;

}    