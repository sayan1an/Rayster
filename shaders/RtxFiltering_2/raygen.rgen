#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "../commonMath.h"
#include "common.h"

layout(binding = 0, set = 0) uniform accelerationStructureNV tlas_global;
layout(binding = 1, set = 0) uniform accelerationStructureNV tlas_lightSource;
layout(binding = 2, set = 0, rgba32f) uniform readonly image2D normalImage;
layout(binding = 3, set = 0, rgba16f) uniform readonly image2D otherImage;
layout(binding = 4, set = 0, rgba16f) uniform readonly image2D stencilImage;
layout(binding = 5, set = 0) uniform sampler2D shadowMapTex;
layout(binding = 6, set = 0, rgba32f) uniform image2DArray outImage;
layout(binding = 7, set = 0) uniform CameraProperties 
{
	mat4 view;
    mat4 proj;
    mat4 viewInv;
    mat4 projInv;
} cam;

layout(binding = 8, set = 0) readonly buffer LightVertices { vec4 v[]; } lightVertices;
layout(binding = 9, set = 0) readonly buffer DiscretePdf { float bins[]; } discretePdf;
layout(binding = 10, set = 0) readonly buffer RandomSquareSamples { vec2 v[]; } coherentSamples;
layout(binding = 11, set = 0) buffer RandomGeneratorState { uint state[]; } randGenState;

layout (push_constant) uniform pcBlock {
	float power;
	uint discretePdfSize;
	uint numSamples;
	uint level;
	float shadowRayCutoff;
	float shadowRayCutoffProb;
} pcb;

layout(location = 0) rayPayloadNV vec3 radiance;

uint xorshiftState;

vec3 rand3(inout uint xorshiftState)
{	
	vec3 ret;
	
	ret.x = xorshift(xorshiftState) / 4294967296.0;     
    ret.y = xorshift(xorshiftState) / 4294967296.0;
	ret.z = xorshift(xorshiftState) / 4294967296.0;

	return ret;
}

float probFunc(in float x)
{
	float ret = abs(x);

	return ret > pcb.shadowRayCutoff ? pcb.shadowRayCutoffProb : 1.0;
}

void shadowRayAreaLight(in float fullRayTraceProb, in float shadowEstimate, in vec3 lightPosition, in vec3 viewDir, in vec3 origin, in vec3 surfaceNormal, in float bsdfType, in float specularAlpha, out vec3 diffComp, out vec3 specComp, out float lightHit)
{	
	diffComp = vec3(0);
	specComp = vec3(0);
	lightHit = 1;

	float distance = length(lightPosition - origin);
	vec3 lightDir = (lightPosition - origin) / distance; // for testing (Mirror):2 * dot(surfaceNormal, viewDir) * surfaceNormal - viewDir;
	
	float cos = dot(lightDir, surfaceNormal);
	
	if (cos < 0) return;
	
	radiance = -lightDir;
	
	float randumNum = xorshift(xorshiftState) / 4294967296.0;
	int raytraceFlag =  randumNum < fullRayTraceProb ? 1 : ((shadowEstimate > 0.5) ? 0 : -1);
	
	if (raytraceFlag > 0)
		traceNV(tlas_global, gl_RayFlagsOpaqueNV, gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV , 1, 0, 0, origin, 0.01f, lightDir, 10000.0f, 0);
	else if (raytraceFlag == 0)
		traceNV(tlas_lightSource, gl_RayFlagsOpaqueNV, gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV, 0, 0, 0, origin, 0.01f, lightDir, 10000.0f, 0);
	else 
		radiance = vec3(0);

	lightHit = radiance.x + radiance.y + radiance.z > 0 ? 1 : 0;
	radiance /= (distance * distance);
	specComp = bsdfType > 0.5f ? radiance * ggxBrdf(viewDir, lightDir, surfaceNormal, specularAlpha) : vec3(0);
	diffComp = radiance * cos / PI;
}

vec2 uvToBary(in uint index)
{	
	vec2 bary = coherentSamples.v[index];
	bary.x = 1.0 - sqrt(bary.x);
	bary.y = (1.0 - bary.x) * (1.0 - bary.y);

	return bary;
}

vec2 randTobary(in vec2 uv)
{
	vec2 bary = uv;
	bary.x = 1.0 - sqrt(bary.x);
	bary.y = (1.0 - bary.x) * (1.0 - bary.y);

	return bary;
}

void main()
{	
	const ivec2 pixel = ivec2(gl_LaunchIDNV.xy);
	float lightPercent = 0;
	vec3 diffComp = vec3(0);
	vec3 specComp = vec3(0);
	float alpha = 0;
	vec4 stencil = imageLoad(stencilImage, pixel / 2);
	
	if (stencil.w > 0.5 && stencil.w < 1.5)
	{	
		alpha = 1;

		vec2 texCoord = (vec2(pixel) + vec2(0.5)) / vec2(gl_LaunchSizeNV.xy);
		float shadowEstimate = texture(shadowMapTex, texCoord).r;
		float fullRayTraceProb = probFunc(shadowEstimate - 0.5);// exp(-(shadowEstimate - 0.5) * (shadowEstimate - 0.5) / 0.1);
		xorshiftState = randGenState.state[pixel.y * gl_LaunchSizeNV.x + pixel.x];
		
				
		const vec4 other = imageLoad(otherImage, pixel).rgba;
		const vec4 normalDepth = imageLoad(normalImage, pixel).rgba;

		// If the primary intersection is a light source
		if (other.w > 3.5 && other.w < 4.5) 
			diffComp = vec3(1.0);
					
		// primary hit point is valid
		else if (other.w > -0.5f) {
			vec2 offset = vec2(offsetCalc(pixel.x & 1, pcb.level), offsetCalc(pixel.y & 1, pcb.level));
			const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + offset;
			const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
			vec2 d = inUV * 2.0 - 1.0;

			vec4 origin = cam.viewInv * vec4(0,0,0,1);
			vec4 target = cam.projInv * vec4(d.x, d.y, 1, 1) ;
			vec4 viewDir = cam.viewInv * vec4(normalize(target.xyz), 0) ;
		
			// for shadow rays
			origin = origin + (normalDepth.w - 0.000f) * viewDir;
			
			vec3 spec, diff;
			float lightHit;
			for (uint i = 0; i < pcb.numSamples; i++) {
				//vec2 bary = uvToBary(i); 
				//uint index = i & 1;
				vec3 bary = rand3(xorshiftState);
				bary.xy = randTobary(bary.xy);
				uint index = bary.z > 0.5 ? 0 : 1;

				shadowRayAreaLight(fullRayTraceProb, shadowEstimate, (lightVertices.v[3*index] * bary.x + lightVertices.v[3*index + 1] * bary.y + lightVertices.v[3*index + 2] * (1 - bary.x - bary.y)).xyz,
					-viewDir.xyz, origin.xyz, normalDepth.xyz, other.w, other.x, diff, spec, lightHit);

				diffComp += diff;
				specComp += spec;
				lightPercent += lightHit;
			}
					
			diffComp *= pcb.power / pcb.numSamples;
			specComp *= pcb.power / pcb.numSamples;
			lightPercent /= pcb.numSamples;
		}
		
		
		randGenState.state[pixel.y * gl_LaunchSizeNV.x + pixel.x] = xorshiftState;
	}

	imageStore(outImage, ivec3(pixel, 0), vec4(diffComp, alpha));
	imageStore(outImage, ivec3(pixel, 1), vec4(specComp, lightPercent));
}
