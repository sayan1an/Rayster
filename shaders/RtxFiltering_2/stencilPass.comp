#version 450

layout (local_size_x = 8, local_size_y = 8) in;

layout (binding = 0, rgba32f) uniform readonly image2D inNormal;
layout (binding = 1, rgba32f) uniform readonly image2D inPrevFrame;
layout (binding = 2, rgba16f) uniform image2D outStencil;
layout (binding = 3, rgba16f) uniform image2D outStencil2;
layout (binding = 4, rgba16f) uniform image2D outStencil3;

shared vec4 sMeanNormalDepth[8][8];
shared vec4 sVarNormalDepth[8][8];

shared vec3 sMeanFrame[8][8];
shared vec3 sVarFrame[8][8];

#define CALC_MEAN_VAR(TYPE) \
	void calcMeanVar(in TYPE v00, in TYPE v01, in TYPE v10, in TYPE v11, out TYPE mean, out TYPE var) \
	{ \
		mean = (v00 + v01 + v10 + v11) / 4.0f; \
		var = (v00 - mean) * (v00 - mean) + (v01 - mean) * (v01 - mean) + (v10 - mean) * (v10 - mean) + (v11 - mean) * (v11 - mean); \
		var = var / 4.0f; \
	}

//https://www.emathzone.com/tutorials/basic-statistics/combined-variance.html
#define COMBINE_MEAN_VAR(TYPE, SHARED_CACHE_NAME_MEAN, SHARED_CACHE_NAME_VAR) \
	void combineMeanVar(ivec2 block, out TYPE mean, out TYPE var) \
	{ \
		TYPE m00 = SHARED_CACHE_NAME_MEAN[2*block.y][2*block.x]; \
		TYPE m01 = SHARED_CACHE_NAME_MEAN[2*block.y][2*block.x + 1]; \
		TYPE m10 = SHARED_CACHE_NAME_MEAN[2*block.y + 1][2*block.x]; \
		TYPE m11 = SHARED_CACHE_NAME_MEAN[2*block.y + 1][2*block.x + 1]; \
		\
		TYPE v00 = SHARED_CACHE_NAME_VAR[2*block.y][2*block.x]; \
		TYPE v01 = SHARED_CACHE_NAME_VAR[2*block.y][2*block.x + 1]; \
		TYPE v10 = SHARED_CACHE_NAME_VAR[2*block.y + 1][2*block.x]; \
		TYPE v11 = SHARED_CACHE_NAME_VAR[2*block.y + 1][2*block.x + 1]; \
		\
		mean = (m00 + m11 + m10 + m11) / 4.0f; \
		var = v00 + v01 + v10 + v11 + (m00 - mean) * (m00 - mean) + (m01 - mean) * (m01 - mean) + (m10 - mean) * (m10 - mean) + (m11 - mean) * (m11 - mean); \
		var = var / 4.0f; \
	}

CALC_MEAN_VAR(vec4)
CALC_MEAN_VAR(vec3)

COMBINE_MEAN_VAR(vec4, sMeanNormalDepth, sVarNormalDepth)
COMBINE_MEAN_VAR(vec3, sMeanFrame, sVarFrame)

vec3 var2Std(in vec4 varN, in vec4 meanN, in vec3 varF)
{
	return vec3(sqrt(varN.x + varN.y + varN.z), sqrt(varN.w) / (meanN.w  + 0.0000001), sqrt((varF.x + varF.y + varF.z) / 3.0f));
}

void main()
{	
	ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	vec4 n00 = imageLoad(inNormal, pixel * 2).rgba; 
	vec4 n01 = imageLoad(inNormal, pixel * 2 + ivec2(0,1)).rgba;
	vec4 n10 = imageLoad(inNormal, pixel * 2 + ivec2(1,0)).rgba;
	vec4 n11 = imageLoad(inNormal, pixel * 2 + ivec2(1,1)).rgba;

	vec3 p00 = imageLoad(inPrevFrame, pixel * 2).rgb;
	vec3 p01 = imageLoad(inPrevFrame, pixel * 2 + ivec2(0,1)).rgb;
	vec3 p10 = imageLoad(inPrevFrame, pixel * 2 + ivec2(1,0)).rgb;
	vec3 p11 = imageLoad(inPrevFrame, pixel * 2 + ivec2(1,1)).rgb;

	vec4 meanNormalDepth, varNormalDepth; vec3 meanLastFrame, varLastFrame;
	calcMeanVar(n00, n01, n10, n11, meanNormalDepth, varNormalDepth); calcMeanVar(p00, p01, p10, p11, meanLastFrame, varLastFrame);
	
	uint tx = gl_LocalInvocationID.x;
	uint ty = gl_LocalInvocationID.y;
	sMeanNormalDepth[ty][tx] = meanNormalDepth; sMeanFrame[ty][tx] = meanLastFrame;
	sVarNormalDepth[ty][tx] = varNormalDepth; sVarFrame[ty][tx] = varLastFrame;
	
	imageStore(outStencil, pixel, vec4(var2Std(varNormalDepth, meanNormalDepth, varLastFrame), 0));

	memoryBarrierShared();
	barrier();
		
	if (tx < 4 && ty < 4) {
		combineMeanVar(ivec2(tx,ty), meanNormalDepth, varNormalDepth); combineMeanVar(ivec2(tx,ty), meanLastFrame, varLastFrame);

		sMeanNormalDepth[ty][tx] = meanNormalDepth; sMeanFrame[ty][tx] = meanLastFrame;
		sVarNormalDepth[ty][tx] = varNormalDepth;  sVarFrame[ty][tx] = varLastFrame;

		imageStore(outStencil2, 4 * ivec2(gl_WorkGroupID.xy) + ivec2(tx, ty), vec4(var2Std(varNormalDepth, meanNormalDepth, varLastFrame), 0));
	}

	memoryBarrierShared();
	barrier();
	
	if (tx < 2 && ty < 2) {
		combineMeanVar(ivec2(tx,ty), meanNormalDepth, varNormalDepth); combineMeanVar(ivec2(tx,ty), meanLastFrame, varLastFrame);
	
		imageStore(outStencil3, 2 * ivec2(gl_WorkGroupID.xy) + ivec2(tx, ty), vec4(var2Std(varNormalDepth, meanNormalDepth, varLastFrame), 0));
	}
}