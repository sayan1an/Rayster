#version 450

layout (local_size_x = 8, local_size_y = 8) in;

layout (binding = 0, rgba32f) uniform readonly image2D inNormal;
layout (binding = 1, r32f) uniform readonly image2D inShadowMap;
layout (binding = 2) uniform sampler2D shadowMapBlur;
layout (binding = 3, rgba16f) uniform image2D outStencil;
layout (binding = 4, rgba16f) uniform image2D outStencil2;
layout (binding = 5, rgba16f) uniform image2D outStencil3;

shared vec4 sMeanNormalDepth[8][8];
shared vec4 sVarNormalDepth[8][8];

shared float sMeanShadow[8][8];
shared float sVarShadow[8][8];

void meanVarNormalDepth(in vec4 n00, in vec4 n01, in vec4 n10, in vec4 n11, out vec4 mean, out vec4 var)
{
	mean = (n00 + n01 + n10 + n11) / 4.0f;
	var = (n00 - mean) * (n00 - mean) + (n01 - mean) * (n01 - mean) + (n10 - mean) * (n10 - mean) + (n11 - mean) * (n11 - mean);
	var = var / 4.0f;
}

void meanVarShadow(in float s00, in float s01, in float s10, in float s11, out float mean, out float var)
{
	mean = (s00 + s01 + s10 + s11) / 4.0f;
	var = (s00 - mean) * (s00 - mean) + (s01 - mean) * (s01 - mean) + (s10 - mean) * (s10 - mean) + (s11 - mean) * (s11 - mean);
	var = var / 4.0f;
}

vec2 var2StdNormalDepth(in vec4 var, in vec4 mean)
{
	return vec2(sqrt(var.x + var.y + var.z), sqrt(var.w) / (mean.w  + 0.0000001));
}

void meanVarNormalDepthShared(ivec2 block, out vec4 mean, out vec4 var)
{
	vec4 m00 = sMeanNormalDepth[2*block.y][2*block.x];
	vec4 m01 = sMeanNormalDepth[2*block.y][2*block.x + 1];
	vec4 m10 = sMeanNormalDepth[2*block.y + 1][2*block.x];
	vec4 m11 = sMeanNormalDepth[2*block.y + 1][2*block.x + 1];

	vec4 v00 = sVarNormalDepth[2*block.y][2*block.x];
	vec4 v01 = sVarNormalDepth[2*block.y][2*block.x + 1];
	vec4 v10 = sVarNormalDepth[2*block.y + 1][2*block.x];
	vec4 v11 = sVarNormalDepth[2*block.y + 1][2*block.x + 1];

	mean = (m00 + m11 + m10 + m11) / 4.0f;
	//https://www.emathzone.com/tutorials/basic-statistics/combined-variance.html
	var = v00 + v01 + v10 + v11 + (m00 - mean) * (m00 - mean) + (m01 - mean) * (m01 - mean) + (m10 - mean) * (m10 - mean) + (m11 - mean) * (m11 - mean);
	var = var / 4.0f;
}

void meanVarShadowShared(ivec2 block, out float mean, out float var)
{
	float m00 = sMeanShadow[2*block.y][2*block.x];
	float m01 = sMeanShadow[2*block.y][2*block.x + 1];
	float m10 = sMeanShadow[2*block.y + 1][2*block.x];
	float m11 = sMeanShadow[2*block.y + 1][2*block.x + 1];

	float v00 = sVarShadow[2*block.y][2*block.x];
	float v01 = sVarShadow[2*block.y][2*block.x + 1];
	float v10 = sVarShadow[2*block.y + 1][2*block.x];
	float v11 = sVarShadow[2*block.y + 1][2*block.x + 1];

	mean = (m00 + m11 + m10 + m11) / 4.0f;
	//https://www.emathzone.com/tutorials/basic-statistics/combined-variance.html
	var = v00 + v01 + v10 + v11 + (m00 - mean) * (m00 - mean) + (m01 - mean) * (m01 - mean) + (m10 - mean) * (m10 - mean) + (m11 - mean) * (m11 - mean);
	var = var / 4.0f;
}

void main()
{	
	ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	vec4 n00 = imageLoad(inNormal, pixel * 2).rgba; 
	vec4 n01 = imageLoad(inNormal, pixel * 2 + ivec2(0,1)).rgba;
	vec4 n10 = imageLoad(inNormal, pixel * 2 + ivec2(1,0)).rgba;
	vec4 n11 = imageLoad(inNormal, pixel * 2 + ivec2(1,1)).rgba;

	float s00 = imageLoad(inShadowMap, pixel * 2).r;
	float s01 = imageLoad(inShadowMap, pixel * 2 + ivec2(0,1)).r;
	float s10 = imageLoad(inShadowMap, pixel * 2 + ivec2(1,0)).r;
	float s11 = imageLoad(inShadowMap, pixel * 2 + ivec2(1,1)).r;

	ivec2 viewPortSize = ivec2(gl_NumWorkGroups.xy) * ivec2(16, 16);
	s00 += texture(shadowMapBlur, (vec2(pixel * 2) + vec2(0.5,0.5)) / viewPortSize).r; s00 /= 2;
	s01 += texture(shadowMapBlur, (vec2(pixel * 2 + ivec2(0,1)) + vec2(0.5,0.5)) / viewPortSize).r; s01 /= 2;
	s10 += texture(shadowMapBlur, (vec2(pixel * 2 + ivec2(1,0)) + vec2(0.5,0.5)) / viewPortSize).r; s10 /= 2;
	s11 += texture(shadowMapBlur, (vec2(pixel * 2 + ivec2(1,1)) + vec2(0.5,0.5)) / viewPortSize).r; s11 /= 2;

	vec4 meanNormalDepth, varNormalDepth; float meanShadow, varShadow;
	meanVarNormalDepth(n00, n01, n10, n11, meanNormalDepth, varNormalDepth); meanVarShadow(s00, s01, s10, s11, meanShadow, varShadow);
	
	uint tx = gl_LocalInvocationID.x;
	uint ty = gl_LocalInvocationID.y;
	sMeanNormalDepth[ty][tx] = meanNormalDepth; sMeanShadow[ty][tx] = meanShadow;
	sVarNormalDepth[ty][tx] = varNormalDepth; sVarShadow[ty][tx] = varShadow;
	
	imageStore(outStencil, pixel, vec4(var2StdNormalDepth(varNormalDepth, meanNormalDepth), sqrt(varShadow), 0));

	memoryBarrierShared();
	barrier();

	if (tx < 4 && ty < 4) {
		meanVarNormalDepthShared(ivec2(tx,ty), meanNormalDepth, varNormalDepth); meanVarShadowShared(ivec2(tx,ty), meanShadow, varShadow);
	}
	memoryBarrierShared();
	barrier();

	if (tx < 4 && ty < 4) {
		sMeanNormalDepth[ty][tx] = meanNormalDepth; sMeanShadow[ty][tx] = meanShadow;
		sVarNormalDepth[ty][tx] = varNormalDepth;  sVarShadow[ty][tx] = varShadow;

		imageStore(outStencil2, 4 * ivec2(gl_WorkGroupID.xy) + ivec2(tx, ty), vec4(var2StdNormalDepth(varNormalDepth, meanNormalDepth), sqrt(varShadow), 0));
	}

	memoryBarrierShared();
	barrier();

	if (tx < 2 && ty < 2) {
		meanVarNormalDepthShared(ivec2(tx,ty), meanNormalDepth, varNormalDepth); meanVarShadowShared(ivec2(tx,ty), meanShadow, varShadow);
		//sMean[ty][tx] = mean;
		//sVar[ty][tx] = var;

		imageStore(outStencil3, 2 * ivec2(gl_WorkGroupID.xy) + ivec2(tx, ty), vec4(var2StdNormalDepth(varNormalDepth, meanNormalDepth), sqrt(varShadow), 0));
	}
}