#version 450
#extension GL_GOOGLE_include_directive : enable

#include "../commonMath.h"

layout (local_size_x = 2, local_size_y = 2) in;

layout(binding = 0, rgba32f) uniform readonly image2D normalImage;
layout(binding = 1, rgba16f) uniform readonly image2D otherImage;
layout(binding = 2, rgba16f) uniform readonly image2D stencilImage;
layout(binding = 3) buffer RandomGeneratorState { uint state[]; } randGenState;
layout(binding = 4, rgba32f) uniform image2D outMcmc;
layout(binding = 5, rg32f) uniform image2D outMcState;

layout (push_constant) uniform pcBlock {
    uint level;
} pcb;

void main()
{   
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    vec4 stencil = imageLoad(stencilImage, gid / 2);

    if (stencil.w > 0.5 && stencil.w < 1.5) 
    {   
        uint xorshiftState = randGenState.state[gid.y * gl_NumWorkGroups.x * 2 + gid.x];

        uint stride = uint(pow(2, pcb.level) + 0.1);
        ivec2 offset = ivec2(xorshift(xorshiftState) & (stride - 1), xorshift(xorshiftState) & (stride - 1)); // + add offset due to motion vector
        vec2 mcState = imageLoad(outMcState, gid * ivec2(stride, stride) + offset).rg;

        mcState = vec2(pcb.level + 1);
        const vec4 other = imageLoad(otherImage, gid).rgba;
		const vec4 normalDepth = imageLoad(normalImage, gid).rgba;

        // assign mcState undefined if primary ray hitting a light source or escaping the scene

        // read mcState and use as initial value for the Markov Chain
        // if initial state is undefined, initialize with random value and run the chain longer if necessary 

        for (uint y = 0; y < stride; y++)
            for (uint x = 0; x < stride; x++)
                imageStore(outMcState, gid * ivec2(stride, stride) + ivec2(x, y), vec4(offset.x / 4.0, offset.y / 4.0, 0, 0));
    }
}